package main

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"

	"github.com/docker/docker/api/types/versions"
	"github.com/google/go-github/v68/github"
	"github.com/malletgaetan/dockermon/internal/config"
	"gopkg.in/yaml.v3"
)

const (
	mobyAPIDocURL = "https://raw.githubusercontent.com/moby/moby/refs/heads/master/docs/api/"
)

type APISpec struct {
	Paths map[string]map[string]struct {
		Description string `yaml:"description"`
		Parameters  []struct {
			Name        string `yaml:"name"`
			In          string `yaml:"in"`
			Description string `yaml:"description"`
			Schema      struct {
				Type string `yaml:"type"`
			} `yaml:"schema"`
		} `yaml:"parameters"`
		Responses map[string]struct {
			Description string `yaml:"description"`
		} `yaml:"responses"`
	} `yaml:"paths"`
}

func getFilenames() []string {
	ctx := context.Background()
	client := github.NewClient(nil)

	_, contents, _, err := client.Repositories.GetContents(
		ctx,
		"moby",
		"moby",
		"docs/api",
		&github.RepositoryContentGetOptions{},
	)

	if err != nil {
		panic(fmt.Sprintf("failed to github get content: %v", err))
	}

	files := make([]string, 0, len(contents))

	for _, content := range contents {
		if *content.Type != "file" {
			continue
		}
		filename := *content.Name
		i := strings.LastIndex(filename, ".")
		if i == -1 || i+1 >= len(filename) || filename[0] != 'v' || filename[i:] != ".yaml" {
			continue
		}
		version := filename[1:i]
		if versions.LessThan(version, config.MinAPIVersion) {
			continue
		}
		files = append(files, version)
	}
	return files
}

func getSpec(url string) *APISpec {
	resp, err := http.Get(url)
	if err != nil {
		panic(fmt.Sprintf("failed to fetch API doc: %v", err))
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		panic(fmt.Sprintf("bad status: %v", resp.StatusCode))
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(fmt.Sprintf("failed to read response body: %v", err))
	}

	var spec APISpec
	err = yaml.Unmarshal(body, &spec)
	if err != nil {
		panic(fmt.Sprintf("failed to parse YAML: %v", err))
	}

	return &spec
}

func quote(a string) string {
	return "\"" + a + "\""
}

func tab(a string) string {
	return "\t" + a
}

func genVersionEntry(version string, description string) string {
	code := tab(quote(version)) + ": {\n"
	for _, line := range strings.Split(description, "\n") {
		if line == "" {
			continue
		}
		words := strings.Split(line, " ")
		if len(words) < 3 {
			continue
		}
		if words[1] != "report" {
			continue
		}
		typ := strings.ToLower(words[0])
		code += tab(tab(quote(typ[:len(typ)-1]))) + ": {"
		first := true
		for _, word := range words {
			if word[0] != '`' {
				continue
			}
			if !first {
				code += ", "
			}
			first = false
			code += quote(word[1:strings.LastIndex(word, "`")])
		}
		code += "},\n"
	}
	code += tab("},\n")
	return code
}

func main() {
	code := `package config

// generated by cmd/gen/configVersion.go

var configVersion = map[string]map[string][]string{
`

	versions := getFilenames()

	for _, version := range versions {
		spec := getSpec(mobyAPIDocURL + "v" + version + ".yaml")
		code += genVersionEntry(version, spec.Paths["/events"]["get"].Description)
	}

	code += "}"

	err := os.WriteFile("./internal/config/version.go", []byte(code), 0o022)
	if err != nil {
		panic(fmt.Sprintf("failed to write file: %v", err))
	}

	fmt.Println("File generated!")
}
